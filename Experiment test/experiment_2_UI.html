<!-- User interface for experiment 2
Runs 20 sequences and save results as .csv file
Stores the actual actuators as output -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactile Pattern Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            width: 800px;
            max-width: 95%;
            text-align: center;
        }
        
        .title {
            font-size: 24px;
            margin-bottom: 20px;
            color: #333;
        }
        
        .subtitle {
            font-size: 18px;
            margin-bottom: 10px;
            color: #555;
        }
        
        .actuator-layout {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            position: relative;
        }
        
        .square-group {
            position: relative;
            width: 150px;
            height: 150px;
            margin-right: 40px;
        }
        
        .center-square {
            position: absolute;
            width: 100px;
            height: 100px;
            background-color: #ff7846;
            border-radius: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        /* Adjust 5 & 6 to vertical layout */
        .oval-group {
            position: relative;
            width: 60px;
            height: 180px;
            margin-right: 40px;
        }
        
        .center-oval {
            position: absolute;
            width: 60px;
            height: 180px;
            background-color: #ff7846;
            border-radius: 30px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .distal-group {
            position: relative;
            width: 60px;
            height: 60px;
        }
        
        .distal-circle {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: #ff7846;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .actuator {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #1a657e;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            z-index: 2;
        }
        
        .actuator.selected {
            background-color: #ff7846;
        }
        
        .actuator:hover {
            background-color: #2580a0;
        }
        
        /* Square group positions */
        .actuator1 { top: 0; left: 50px; }
        .actuator2 { top: 50px; right: 100px; }
        .actuator3 { bottom: 0; left: 50px; }
        .actuator4 { bottom: 50px; right: 0; }

        /* Oval group positions */
        /* Vertically stacked actuators 5 & 6 */
        .actuator5 {
            top: 25px;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .actuator6 {
            bottom: 25px;
            left: 50%;
            transform: translate(-50%, 50%);
        }

        /* Distal group position */
        .actuator7 { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        
        .accel-decel-btn {
            padding: 8px 16px;
            font-size: 14px;
            background-color: #1a657e;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            min-width: 80px;
        }
        
        .accel-decel-btn:hover {
            background-color: #2580a0;
        }
        
        .accel-decel-btn.selected {
            background-color: #ff7846;
        }

        .buttons {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #1a657e;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2580a0;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .sequence-info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            text-align: left;
        }
        
        .feedback {
            margin-top: 20px;
            padding: 10px;
            color: #1a657e;
            font-weight: bold;
        }
        
        #startPage, #endPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #endPage {
            display: none;
        }
        
        .progress-bar {
            width: 80%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background-color: #1a657e;
            width: 0%;
            transition: width 0.5s;
        }
        
        .instructions {
            max-width: 80%;
            text-align: left;
            margin: 20px 0;
            line-height: 1.6;
        }
        
        .start-btn {
            padding: 15px 40px;
            font-size: 18px;
        }
        
        .arduino-status {
            margin: 10px 0;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 5px;
            color: #555;
        }
        
        .connection-panel {
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        /* .debug-info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            text-align: left;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        } */

        .debug-info {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
            text-align: left;
            max-height: 300px; /* Increased from 150px */
            overflow-y: auto;
            display: none;
        }

        #stageTransitionPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .stage-info {
            text-align: center;
            max-width: 600px;
            margin: 20px;
        }

        .stage-title {
            font-size: 28px;
            color: #1a657e;
            margin-bottom: 20px;
        }

        .stage-description {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 30px;
            color: #555;
        }

        .continue-btn {
            padding: 15px 40px;
            font-size: 18px;
            background-color: #1a657e;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .continue-btn:hover {
            background-color: #2580a0;
        }

        .actuator-section, .control-section {
            display: block;
        }

        .actuator-section.hidden, .control-section.hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Start Page -->
    <div id="startPage">
        <div class="container">
            <h1 class="title">Tactile Pattern Recognition Study</h1>
            <div class="instructions">
                <p>Welcome to the tactile pattern recognition study. During this experiment, you will:</p>
                <ol>
                    <li>Experience different tactile patterns on your leg</li>
                    <li>After each pattern, select which actuators you felt were activated</li>
                    <li>Click the "Next" button to proceed to the next pattern</li>
                </ol>
                <p>Each pattern lasts 4-5 seconds. After that you can take your time to select the pattern you sensed. The experiment will take approximately 20 minutes to complete.</p>
                <p><strong>Important:</strong> Please maintain the same position throughout the experiment for consistent results.</p>
            </div>
            
            <div class="connection-panel">
                <h3>Arduino Connection</h3>
                <p>The experiment requires a connection to your Arduino device.</p>
                <button id="connectBtn" onclick="connectToArduino()">Connect to Arduino</button>
                <div class="arduino-status" id="arduinoStatus">Not connected</div>
            </div>
            
            <button class="start-btn" id="beginBtn" onclick="startExperiment()" disabled>Begin Experiment</button>
        </div>
    </div>
    
    <div id="stageTransitionPage">
        <div class="container">
            <div class="stage-info">
                <h1 class="stage-title" id="stageTitle">Stage 1: Constant Speed, 1D Patterns</h1>
                <div class="stage-description" id="stageDescription">
                    You will now experience 10 patterns with constant speed in 1-dimensional movements.
                </div>
                <button class="continue-btn" onclick="continueToStage()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Main Interface -->
    <div class="container">
        <h1 class="title">Tactile Pattern Interface</h1>
        <h2 class="subtitle">Sequence <span id="currentSequence">1</span> of <span id="totalSequences">30</span></h2>
        
        <div class="progress-bar">
            <div class="progress" id="progressBar"></div>
        </div>
        
        <div class="actuator-section" id="actuatorSection">
            <div class="actuator-layout">
                <!-- <div class="square-group">
                    <div class="center-square"></div>
                    <div class="actuator actuator1" data-id="1" onclick="toggleActuator(this)">1</div>
                    <div class="actuator actuator2" data-id="2" onclick="toggleActuator(this)">2</div>
                    <div class="actuator actuator3" data-id="3" onclick="toggleActuator(this)">3</div>
                    <div class="actuator actuator4" data-id="4" onclick="toggleActuator(this)">4</div>
                </div>
                
                <div class="oval-group">
                    <div class="center-oval"></div>
                    <div class="actuator actuator5" data-id="5" onclick="toggleActuator(this)">5</div>
                    <div class="actuator actuator6" data-id="6" onclick="toggleActuator(this)">6</div>
                </div>
                 -->
                <!-- <div class="distal-group">
                    <div class="distal-circle"></div>
                    <div class="actuator actuator7" data-id="7" onclick="toggleActuator(this)">7</div>
                </div> -->
            </div>

            <!-- <div class="sequence-info">
                <p>Click on the actuators you felt were activated during the pattern.</p>
                <p>Selected: <span id="selectedActuators">None</span></p>
            </div> -->
        </div>

        <!-- Acceleration/Constant Speed Controls -->
        <div class="control-section" id="controlSection">
            <!-- <div class="control-buttons">
                <button class="accel-decel-btn" id="accelBtn" onclick="toggleAcceleration()">
                    Acceleration
                </button>
                <button class="accel-decel-btn" id="decelBtn" onclick="toggleConstSpeed()">
                    Constant Speed
                </button>
            </div> -->

            <!-- <div class="sequence-info">
                <p>Click on the corresponding speed button you perceive from the actuators.</p>
                <p>Selected: <span id="selectedActuators">None</span></p>
            </div> -->
        </div>

        <div class="feedback" id="feedback"></div>
        
        <div class="buttons">
            <button id="nextBtn" onclick="nextSequence()">Next Pattern</button>
            <button id="downloadBtn" onclick="downloadResults()" disabled>Download Results</button>
        </div>
        
        <div class="debug-info" id="debugInfo">
            <h3>Debug Information</h3>
            <div id="debugContent"></div>
            <button onclick="document.getElementById('debugInfo').style.display = 'none'">Hide Debug Info</button>
        </div>
    </div>
    
    <!-- End Page -->
    <div id="endPage">
        <div class="container">
            <h1 class="title">Experiment Completed</h1>
            <p>Thank you for participating in the tactile pattern recognition study.</p>
            <p>Your results have been recorded successfully.</p>
            <button onclick="downloadResults()">Download Results</button>
            <button onclick="restartExperiment()">Start New Experiment</button>
        </div>
    </div>
    
    <script>
        // Configuration - Updated for 2 stages
        const totalSequences = 22; // 10 sequences per stage × 2 stages (two extra: 1 for test run 1 for bug)
        const sequencesPerStage = 11;
        let currentSequence = 0;
        let currentStage = 1;
        let sequenceInStage = 0; // Track position within current stage
        let experimentActive = false;
        let experimentData = [];
        let selectedActuators = [];
        let actualActuatorsInPattern = [];
        let serialPort = null;
        let serialWriter = null;
        let arduinoConnected = false;

        // Stage information
        const stageInfo = {
            1: {
                title: "Stage 1: 1D Patterns",
                description: "You will now experience 10 patterns in 1-dimensional movements."
            },
            2: {
                title: "Stage 2: 2D Patterns", 
                description: "You will now experience 10 patterns in 2-dimensional movements."
            },
        };

        // Initialize the interface
        document.getElementById('totalSequences').textContent = totalSequences;
        updateProgress();
        
        // Toggle actuator selection
        function toggleActuator(element) {
            if (!experimentActive) return;
            
            const actuatorId = parseInt(element.getAttribute('data-id'));
            
            if (element.classList.contains('selected')) {
                // Remove from selection
                element.classList.remove('selected');
                selectedActuators = selectedActuators.filter(id => id !== actuatorId);
            } else {
                // Add to selection
                element.classList.add('selected');
                selectedActuators.push(actuatorId);
            }
            
            // Update the display
            updateSelectedActuators();
        }
        
        // Update the list of selected actuators
        function updateSelectedActuators() {
            const selectedElement = document.getElementById('selectedActuators');
            
            if (selectedActuators.length === 0) {
                selectedElement.textContent = 'None';
            } else {
                selectedElement.textContent = selectedActuators.join(', ');
            }
        }
        
        // Variables to track acceleration/constant speed state
        let accelerationSelected = false;
        let ConstSpeedSelected = false;
        let actualAccelerationInPattern = false;
        let actualConstSpeedInPattern = false;

        // Toggle acceleration button
        function toggleAcceleration() {
            if (!experimentActive) return;
            
            const accelBtn = document.getElementById('accelBtn');
            
            if (accelerationSelected) {
                // Remove acceleration selection
                accelBtn.classList.remove('selected');
                accelerationSelected = false;
            } else {
                // Add acceleration selection
                accelBtn.classList.add('selected');
                accelerationSelected = true;
                
                // If constant speed was selected, deselect it (assuming mutual exclusivity)
                if (ConstSpeedSelected) {
                    const decelBtn = document.getElementById('decelBtn');
                    decelBtn.classList.remove('selected');
                    ConstSpeedSelected = false;
                }
            }
            
            // Update the display
            updateAccelDecelSelection();
        }

        // Toggle constant speed button
        function toggleConstSpeed() {
            if (!experimentActive) return;
            
            const decelBtn = document.getElementById('decelBtn');
            
            if (ConstSpeedSelected) {
                // Remove constant speed selection
                decelBtn.classList.remove('selected');
                ConstSpeedSelected = false;
            } else {
                // Add constant speed selection
                decelBtn.classList.add('selected');
                ConstSpeedSelected = true;
                
                // If acceleration was selected, deselect it (assuming mutual exclusivity)
                if (accelerationSelected) {
                    const accelBtn = document.getElementById('accelBtn');
                    accelBtn.classList.remove('selected');
                    accelerationSelected = false;
                }
            }
            
            // Update the display
            updateAccelDecelSelection();
        }

        // Update the acceleration/constant speed selection display
        function updateAccelDecelSelection() {
            // Optional: Log the current selection state
            console.log('Acceleration selected:', accelerationSelected);
            console.log('Constant speed selected:', ConstSpeedSelected);
        }

        // Connect to Arduino via Web Serial API
        async function connectToArduino() {
            if ('serial' in navigator) {
                try {
                    // Request port access
                    const port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 115200 });
                    
                    serialPort = port;
                    arduinoConnected = true;
                    
                    // Update UI
                    document.getElementById('arduinoStatus').textContent = "Connected";
                    document.getElementById('arduinoStatus').style.color = "green";
                    document.getElementById('connectBtn').textContent = "Reconnect";
                    document.getElementById('beginBtn').disabled = false;
                    
                    // Set up reading from Arduino
                    readFromArduino();
                    
                    addDebugMessage("Arduino connected successfully!");
                    
                } catch (err) {
                    console.error("Error connecting to Arduino:", err);
                    document.getElementById('arduinoStatus').textContent = "Connection failed: " + err.message;
                    document.getElementById('arduinoStatus').style.color = "red";
                    addDebugMessage("Arduino connection failed: " + err.message);
                }
            } else {
                console.warn("Web Serial API not supported in this browser");
                document.getElementById('arduinoStatus').textContent = "Web Serial API not supported in this browser";
                document.getElementById('arduinoStatus').style.color = "red";
                document.getElementById('beginBtn').disabled = false; // Allow to start anyway
                addDebugMessage("Web Serial API not supported. Will simulate patterns.");
            }
        }
        
        // // Add debug message
        // function addDebugMessage(message) {
        //     const debugContent = document.getElementById('debugContent');
        //     const timestamp = new Date().toLocaleTimeString();
        //     debugContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
        //     document.getElementById('debugInfo').style.display = 'block';
        //     debugContent.scrollTop = debugContent.scrollHeight;
        // }
        function addDebugMessage(message) {
            const debugContent = document.getElementById('debugContent');
            const timestamp = new Date().toLocaleTimeString();
            debugContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            document.getElementById('debugInfo').style.display = 'block';
            debugContent.scrollTop = debugContent.scrollHeight; // This line already exists and handles auto-scroll
        }
        
        // Read data from Arduino
        async function readFromArduino() {
            if (!serialPort || !serialPort.readable) {
                console.error("Serial port not readable");
                return;
            }
            
            const reader = serialPort.readable.getReader();
            
            try {
                let buffer = '';
                
                while (true) {
                    const { value, done } = await reader.read();
                    
                    if (done) {
                        reader.releaseLock();
                        break;
                    }
                    
                    // Convert the incoming data to text and process it
                    const textDecoder = new TextDecoder();
                    const chunk = textDecoder.decode(value);
                    buffer += chunk;
                    
                    // Process complete lines
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep the last incomplete line in the buffer
                    
                    for (const line of lines) {
                        if (line.trim()) {
                            processArduinoData(line.trim());
                        }
                    }
                }
            } catch (error) {
                console.error("Error reading from Arduino:", error);
                addDebugMessage("Error reading from Arduino: " + error.message);
            } finally {
                reader.releaseLock();
                arduinoConnected = false;
                document.getElementById('arduinoStatus').textContent = "Disconnected";
                document.getElementById('arduinoStatus').style.color = "red";
            }
        }
        
        // Process data received from Arduino
        function processArduinoData(data) {
            console.log("Data from Arduino:", data);
            addDebugMessage("From Arduino: " + data);
            
            // If data contains actuator information, extract it
            if (data.includes("Actuators:")) {
                const match = data.match(/Actuators: (.+)/);
                if (match && match[1]) {
                    // Parse the actuators used
                    actualActuatorsInPattern = match[1]
                        .split(',')
                        .map(item => parseInt(item.trim()))
                        .filter(num => !isNaN(num));
                    
                    console.log("Pattern used actuators:", actualActuatorsInPattern);
                    addDebugMessage("Pattern used actuators: " + actualActuatorsInPattern.join(", "));
                }
            } else if (data.includes("Pattern complete")) {
                // Pattern execution is complete
                const feedback = document.getElementById('feedback');
                feedback.textContent = "Pattern complete. Please select which actuators/speed you felt were used.";
                document.getElementById('nextBtn').disabled = false;
            }
        }
        
        function startWithCountdown(seconds) {
            let countdown = seconds;
            
            const countdownInterval = setInterval(() => {
                console.log(`Starting in ${countdown}...`);
                countdown--;
                
                if (countdown < 0) {
                    clearInterval(countdownInterval);
                    console.log("Starting now!");
                    runPattern();
                }
            }, 1000); // Update every second
        }

        // Modified startExperiment function
        function startExperiment() {
            document.getElementById('startPage').style.display = 'none';
            currentSequence = 1;
            currentStage = 1;
            sequenceInStage = 1;
            experimentData = [];
            experimentActive = true;
            
            // Update interface for stage 1
            updateInterfaceForStage(currentStage);

            addDebugMessage("Experiment started");
            
            // Show stage 1 transition page
            showStageTransition();
        }

        // New function to show stage transition
        function showStageTransition() {
            const stageTitle = document.getElementById('stageTitle');
            const stageDescription = document.getElementById('stageDescription');
            
            stageTitle.textContent = stageInfo[currentStage].title;
            stageDescription.textContent = stageInfo[currentStage].description;
            
            document.getElementById('stageTransitionPage').style.display = 'flex';
        }

        // function updateInterfaceForStage(stage) {
        //     const actuatorSection = document.getElementById('actuatorSection');
        //     const controlSection = document.getElementById('controlSection');
            
        //     if (stage === 3) {
        //         // Stage 3: Show only speed controls
        //         actuatorSection.classList.add('hidden');
        //         controlSection.classList.remove('hidden');
        //     } else {
        //         // Stages 1, 2, 4: Show only actuators
        //         actuatorSection.classList.remove('hidden');
        //         controlSection.classList.add('hidden');
        //     }
        // }

        // Modified continueToStage function
        function continueToStage() {
            document.getElementById('stageTransitionPage').style.display = 'none';
            
            // Update interface based on current stage
            // updateInterfaceForStage(currentStage);

            // Reset selections for the new stage
            resetActuators();
            
            // Start the pattern for this stage immediately
            runPatternForCurrentStage().then(() => {
                if (!arduinoConnected) {
                    setTimeout(() => {
                        document.getElementById('nextBtn').disabled = false;
                        document.getElementById('feedback').textContent = "Pattern complete. Please select which actuators/speed you felt were used.";
                    }, 3000);
                }
            });
            
            // Update UI
            document.getElementById('currentSequence').textContent = currentSequence;
            updateProgress();
            
            // Show feedback
            const feedback = document.getElementById('feedback');
            feedback.textContent = "Running pattern... Please wait.";
            
            // Disable next button temporarily
            document.getElementById('nextBtn').disabled = true;
        }

        // Modified nextSequence function
        async function nextSequence() {
            // Save data from current sequence (if we're past sequence 0)
            if (currentSequence > 0) {
                saveSequenceData();
            }
            
            currentSequence++;
            sequenceInStage++;
            
            // Check if we just completed a stage (before running next pattern)
            if (sequenceInStage > sequencesPerStage && currentStage < 2) {
                // We just finished a stage, prepare for next stage
                currentStage++;
                sequenceInStage = 1; // Reset to 1 for the new stage
                
                // Update UI
                document.getElementById('currentSequence').textContent = currentSequence;
                updateProgress();
                
                // Show stage transition page
                showStageTransition();
                return;
            }
            
            // Check if experiment is complete
            if (currentSequence > totalSequences) {
                experimentComplete();
                return;
            }
            
            // Update UI
            document.getElementById('currentSequence').textContent = currentSequence;
            updateProgress();
            
            // Reset selections
            // resetActuators();
            
            // Disable the next button temporarily
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.disabled = true;
            
            // Show feedback
            const feedback = document.getElementById('feedback');
            feedback.textContent = "Running pattern... Please wait.";
            
            // Run pattern based on current stage
            await runPatternForCurrentStage();
            
            // Re-enable the next button after pattern completes if not connected to Arduino
            if (!arduinoConnected) {
                setTimeout(() => {
                    nextBtn.disabled = false;
                    feedback.textContent = "Pattern complete. Please select which actuators/speed you felt were used.";
                }, 3000);
            }
        }
        
        // New function to run pattern based on current stage
        async function runPatternForCurrentStage() {
            switch(currentStage) {
                case 1:
                    await runPatternStage1();
                    break;
                case 2:
                    await runPatternStage2();
                    break;
                default:
                    console.error("Invalid stage:", currentStage);
            }
        }

        // Function to reset selections for next sequence
        // function resetActuators() {
        //     // Clear actuator selections
        //     selectedActuators = [];
        //     document.querySelectorAll('.actuator.selected').forEach(el => {
        //         el.classList.remove('selected');
        //     });
            
        //     // Clear acceleration/constant speed selections
        //     accelerationSelected = false;
        //     ConstSpeedSelected = false;
        //     document.getElementById('accelBtn').classList.remove('selected');
        //     document.getElementById('decelBtn').classList.remove('selected');
            
        //     // Update displays
        //     updateSelectedActuators();
        //     updateAccelDecelSelection();
        // }

        // Update progress bar
        function updateProgress() {
            const progressBar = document.getElementById('progressBar');
            const percentage = Math.min((currentSequence / totalSequences) * 100, 100);
            progressBar.style.width = percentage + '%';
        }
        
        // Save data from the current sequence
        function saveSequenceData() {
            const data = {
                sequence: currentSequence,
                stage: currentStage,
                sequenceInStage: sequenceInStage,
                selectedActuators: [...selectedActuators],
                actualActuators: [...actualActuatorsInPattern],
                selectedAcceleration: accelerationSelected,
                actualAcceleration: actualAccelerationInPattern,
                selectedConstSpeed: ConstSpeedSelected,
                actualConstSpeed: actualConstSpeedInPattern,
                timestamp: new Date().toISOString()
            };
            
            experimentData.push(data);
            console.log("Saved data for sequence", currentSequence, data);
            addDebugMessage(`Saved data for sequence ${currentSequence} (Stage ${currentStage}): Selected: ${data.selectedActuators.join(', ')}, Actual: ${data.actualActuators.join(', ')}`);
        }

        // Mark experiment as complete
        function experimentComplete() {
            experimentActive = false;
            document.getElementById('endPage').style.display = 'flex';
            document.getElementById('downloadBtn').disabled = false;
            
            addDebugMessage("Experiment completed!");
            
            // Disconnect from Arduino if connected
            disconnectFromArduino();
        }
        
        // Disconnect from Arduino
        async function disconnectFromArduino() {
            if (serialPort && serialPort.readable) {
                try {
                    await serialPort.close();
                    serialPort = null;
                    arduinoConnected = false;
                    document.getElementById('arduinoStatus').textContent = "Disconnected";
                    document.getElementById('arduinoStatus').style.color = "red";
                    addDebugMessage("Disconnected from Arduino");
                } catch (error) {
                    console.error("Error disconnecting from Arduino:", error);
                    addDebugMessage("Error disconnecting from Arduino: " + error.message);
                }
            }
        }
        
        // Download results as CSV
        function downloadResults() {
            // Create CSV content
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Sequence,Stage,Sequence In Stage,Selected Actuators,Actual Actuators,Selected Acceleration,Actual Acceleration,Selected Constant Speed,Actual Constant Speed,Timestamp\n";
            
            experimentData.forEach(data => {
                // Format actuator arrays - handle empty arrays
                const selectedActuators = data.selectedActuators && data.selectedActuators.length > 0 
                    ? data.selectedActuators.join(', ') 
                    : 'None';
                const actualActuators = data.actualActuators && data.actualActuators.length > 0 
                    ? data.actualActuators.join(', ') 
                    : 'None';
                
                // Add all the data including stage info
                csvContent += `${data.sequence},${data.stage},${data.sequenceInStage},"${selectedActuators}","${actualActuators}",${data.selectedAcceleration},${data.actualAcceleration},${data.selectedConstSpeed},${data.actualConstSpeed},${data.timestamp}\n`;
            });
            
            // Create download link and trigger download
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "tactile_pattern_results.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            addDebugMessage("Results downloaded");
        }
        
        // Restart the experiment
        function restartExperiment() {
            document.getElementById('endPage').style.display = 'none';
            document.getElementById('startPage').style.display = 'flex';
            addDebugMessage("Experiment reset");
        }
        
        // =============================================================================
        // STAGE 1: 1D Patterns
        // =============================================================================

        const generateStage1Pattern = (function () {
            const actuatorSets = [
                // 1D patterns only
                [1, 5, 6], [6, 5, 1],
                //[2, 1, 4], [4, 1, 2], 
                [2, 4], [4, 2],
                //[1, 2, 3], [3, 2, 1],
                [1, 3], [3, 1],
                [1, 2], [4, 1],
                [2, 5], [3, 6],
                //backup sequence for test-run: 
                [4, 6]
            ];

            // Create 10 CS commands
            const commandPool = actuatorSets.slice(0, 10).map(set => `CS:${set.join(',')}`);

            // Shuffle once
            for (let i = commandPool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [commandPool[i], commandPool[j]] = [commandPool[j], commandPool[i]];
            }

            return function generateStage1Pattern() {
                if (commandPool.length === 0) return null;

                const command = commandPool.pop();
                const actuators = command.split(':')[1].split(',').map(Number);

                return {
                    type: "CS",
                    actuators: actuators,
                    command: command,
                    hasAcceleration: false,
                    hasConstSpeed: false
                };
            };
        })();

        // =============================================================================
        // STAGE 2: 2D Patterns  
        // =============================================================================

        const generateStage2Pattern = (function () {
            const actuatorSets = [
                // 2D patterns only
                // // Triangle
                // [1, 2, 4], [2, 6, 3], [3, 1, 5],
                // [2, 5, 4], [3, 4, 6], [3, 6, 1]
                // // Square or Rectangle
                // [1, 2, 3, 4], [2, 5, 4, 3],
                // [5, 2, 3, 4], [4, 3, 2, 1],
                // [2, 3, 4, 6]
                //Mixed pattern
                // Triangle
                [2, 6, 3], [3, 1, 5], [2, 5, 4, 3],
                [2, 5, 4], [5, 2, 3, 4],
                // Square or Rectangle
                [1, 2, 3, 4], [1, 2, 4], 
                [3, 6, 1], [4, 3, 2, 1],
                [2, 3, 4, 6], [3, 4, 6],
            ];

            // Create AD:acc commands (All triple activation)
            const commandPool = [
                // ...actuatorSets.slice(0, 5).map(set => `CS:${set.join(',')}`),
                ...actuatorSets.slice(0, 11).map(set => `AD:acc,${set.join(',')}`)
            ];

            // Shuffle once
            for (let i = commandPool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [commandPool[i], commandPool[j]] = [commandPool[j], commandPool[i]];
            }

            return function generateStage2Pattern() {
                if (commandPool.length === 0) return null;

                const command = commandPool.pop();
                let type = "";
                let hasAcceleration = false;
                let hasConstSpeed = false;

                if (command.startsWith("CS:")) {
                    type = "CS";
                    const actuators = command.split(':')[1].split(',').map(Number);
                    return {
                        type: type,
                        actuators: actuators,
                        command: command,
                        hasAcceleration: hasAcceleration,
                        hasConstSpeed: hasConstSpeed
                    };
                } else if (command.startsWith("AD:acc")) {
                    type = "AD:acc";
                    hasAcceleration = true;
                    const actuators = command.split(/[:,]/).slice(1).map(Number);
                    return {
                        type: type,
                        actuators: actuators,
                        command: command,
                        hasAcceleration: hasAcceleration,
                        hasConstSpeed: hasConstSpeed
                    };
                }
            };
        })();

        // =============================================================================
        // STAGE-SPECIFIC RUN PATTERN FUNCTIONS
        // =============================================================================

        // Stage 1 runPattern function
        async function runPatternStage1() {
            const pattern = generateStage1Pattern();
            if (!pattern) return null;
            
            actualActuatorsInPattern = pattern.actuators;
            actualAccelerationInPattern = pattern.hasAcceleration;
            actualConstSpeedInPattern = pattern.hasConstSpeed;

            addDebugMessage(`Running Stage 1 pattern: ${pattern.command}`);
            
            if (arduinoConnected && serialPort && serialPort.writable) {
                try {
                    const writer = serialPort.writable.getWriter();
                    const command = `${pattern.command}\n`;
                    const encoder = new TextEncoder();
                    const data = encoder.encode(command);
                    await writer.write(data);
                    addDebugMessage(`Sent to Arduino: ${command.trim()}`);
                    writer.releaseLock();
                } catch (error) {
                    console.error("Error sending to Arduino:", error);
                    addDebugMessage("Error sending to Arduino: " + error.message);
                    return new Promise(resolve => setTimeout(resolve, 5000));
                }
            } else {
                addDebugMessage("Simulating Stage 1 pattern (no Arduino connection)");
                return new Promise(resolve => setTimeout(resolve, 5000));
            }
        }

        // Stage 2 runPattern function
        async function runPatternStage2() {
            const pattern = generateStage2Pattern();
            if (!pattern) return null;
            
            actualActuatorsInPattern = pattern.actuators;
            actualAccelerationInPattern = pattern.hasAcceleration;
            actualConstSpeedInPattern = pattern.hasConstSpeed;

            addDebugMessage(`Running Stage 3 pattern: ${pattern.command}`);
            
            if (arduinoConnected && serialPort && serialPort.writable) {
                try {
                    const writer = serialPort.writable.getWriter();
                    const command = `${pattern.command}\n`;
                    const encoder = new TextEncoder();
                    const data = encoder.encode(command);
                    await writer.write(data);
                    addDebugMessage(`Sent to Arduino: ${command.trim()}`);
                    writer.releaseLock();
                } catch (error) {
                    console.error("Error sending to Arduino:", error);
                    addDebugMessage("Error sending to Arduino: " + error.message);
                    return new Promise(resolve => setTimeout(resolve, 5000));
                }
            } else {
                addDebugMessage("Simulating Stage 3 pattern (no Arduino connection)");
                return new Promise(resolve => setTimeout(resolve, 5000));
            }
        }

        // Modified processArduinoData function to handle the new command formats
        function processArduinoData(data) {
            console.log("Data from Arduino:", data);
            addDebugMessage("From Arduino: " + data);
            
            // If data contains actuator information, extract it
            if (data.includes("Actuators:")) {
                const match = data.match(/Actuators: (.+)/);
                if (match && match[1]) {
                    // Parse the actuators used
                    actualActuatorsInPattern = match[1]
                        .split(',')
                        .map(item => parseInt(item.trim()))
                        .filter(num => !isNaN(num));
                    
                    console.log("Pattern used actuators:", actualActuatorsInPattern);
                    addDebugMessage("Pattern used actuators: " + actualActuatorsInPattern.join(", "));
                }
            } else if (data.includes("Pattern complete") || data.includes("Command complete")) {
                // Pattern execution is complete
                const feedback = document.getElementById('feedback');
                feedback.textContent = "Pattern complete. Please select which actuators/speed you felt were used.";
                document.getElementById('nextBtn').disabled = false;
            }
        }
    </script>
</body>
</html>
